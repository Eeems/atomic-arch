#!/usr/bin/python
import argparse
import atexit
import os
import shlex
import shutil
import subprocess
import sys
import tarfile
import json

from time import time
from glob import iglob
from datetime import datetime
import traceback
from typing import Callable, cast
from getpass import getpass


OS_NAME = "atomic-arch"
IMAGE = f"eeems/{OS_NAME}"
SYSTEM_PATH = "/var/lib/system"
RETAIN = 5
COMMAND_LINE = ""
NVIDIA_PACKAGES = ["nvidia-open-dkms", "nvidia-container-toolkit", "nvidia-utils"]


def is_root() -> bool:
    return os.geteuid() == 0


def _execute(cmd: str):
    status = os.system(cmd)
    return os.waitstatus_to_exitcode(status)


def execute(cmd: str | list[str], *args: str):
    if not isinstance(cmd, str):
        cmd = shlex.join(cmd)

    if args:
        cmd = f"{cmd} {shlex.join(args)}"

    ret = _execute(cmd)
    if ret:
        raise subprocess.CalledProcessError(ret, cmd, None, None)


def podman_cmd(*args: str):
    if _execute("systemd-detect-virt --quiet --container") == 0:
        return ["podman", "--remote", *args]

    return ["podman", *args]


def podman(*args: str):
    execute(*podman_cmd(*args))


def ostree(*args: str):
    execute("ostree", f"--repo={getattr(ostree, 'repo')}", *args)


setattr(ostree, "repo", "/ostree/repo")


def build_image() -> str:
    with open("/etc/system/Systemfile", "r") as f:
        return [x.split(" ")[1].strip() for x in f.readlines() if x.startswith("FROM")][
            0
        ]


def export(
    tag: str = "latest",
    setup: str = "",
    rootfs: str | None = None,
    workingDir: str | None = None,
):
    if workingDir is None:
        workingDir = SYSTEM_PATH

    if rootfs is None:
        rootfs = os.path.join(workingDir, "rootfs")

    if os.path.exists(rootfs):
        shutil.rmtree(rootfs)

    os.makedirs(rootfs, exist_ok=True)
    os.makedirs(workingDir, exist_ok=True)
    cwd = os.getcwd()
    os.chdir(workingDir)
    timestamp = int(time())
    name = f"export-{tag}-{timestamp}"
    exitFunc1 = atexit.register(podman, "rm", name)
    podman(
        "run",
        f"--name={name}",
        "--privileged",
        "--security-opt=label=disable",
        "--volume=/run/podman/podman.sock:/run/podman/podman.sock",
        f"system:{tag}",
        "-c",
        setup,
    )
    cmd = podman_cmd("export", name)
    process = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    assert process.stdout is not None
    with tarfile.open(fileobj=process.stdout, mode="r|*") as t:
        t.extractall(rootfs, numeric_owner=True, filter="fully_trusted")

    process.stdout.close()
    _ = process.wait()
    if process.returncode != 0:
        raise subprocess.CalledProcessError(process.returncode, cmd, None, None)

    atexit.unregister(exitFunc1)
    podman("rm", name)
    os.chdir(cwd)


TMPFILE_CONF = """
d /var/home 0755 root root -
d /var/lib 0755 root root -
d /var/log/journal 0755 root root -
d /var/media 0755 root root -
d /var/mnt 0755 root root -
d /var/opt 0755 root root -
d /var/roothome 0755 root root -
d /var/srv 0755 root root -
d /var/userlocal 0755 root root -
d /var/userlocal/bin 0755 root root -
d /var/userlocal/etc 0755 root root -
d /var/userlocal/games 0755 root root -
d /var/userlocal/include 0755 root root -
d /var/userlocal/lib 0755 root root -
d /var/userlocal/man 0755 root root -
d /var/userlocal/sbin 0755 root root -
d /var/userlocal/share 0755 root root -
d /var/userlocal/src 0755 root root -
"""


def prepare(rootfs: str, kernelCommandline: str = ""):
    cwd = os.getcwd()
    os.chdir(rootfs)
    with open("etc/system/commandline", "w") as f:
        _ = f.write(kernelCommandline)

    _ = shutil.move("etc", "usr")

    def var_link(name: str):
        shutil.rmtree(name)
        os.symlink(f"var/{name}", name)

    var_link("home")
    var_link("mnt")
    var_link("opt")
    shutil.rmtree("root")
    os.symlink("var/roothome", "root")
    var_link("srv")
    os.mkdir("sysroot")
    os.symlink("sysroot/ostree", "ostree")
    shutil.rmtree("usr/local")
    os.symlink("../var/userlocal", "usr/local")
    with open("usr/lib/tmpfiles.d/ostree-0-integration.conf", "w") as f:
        _ = f.write(TMPFILE_CONF)

    _ = shutil.move("var/lib/pacman", "usr/lib")
    execute(
        "sed",
        "-i",
        "-e",
        r"s|^#\(DBPath\s*=\s*\).*|\1/usr/lib/pacman|g",
        "-e",
        r"s|^#\(IgnoreGroup\s*=\s*\).*|\1modified|g",
        "usr/etc/pacman.conf",
    )
    os.mkdir("usr/lib/pacmanlocal")
    for path in iglob("var/*"):
        if os.path.islink(path) or os.path.isfile(path):
            os.unlink(path)

        else:
            shutil.rmtree(path)

    os.unlink("boot/vmlinuz-linux-zen")
    modulePath = [*iglob("usr/lib/modules/*")][0]
    os.rename("boot/initramfs-linux-zen.img", f"{modulePath}/initramfs.img")
    os.chdir(cwd)


def build(systemfile: str = "/etc/system/Systemfile"):
    cache = "/var/cache/pacman"
    if not os.path.exists(cache):
        os.makedirs(cache, exist_ok=True)

    uuid = (
        subprocess.check_output(["bash", "-c", "uuidgen --time-v7 | cut -c-8"])
        .decode("utf-8")
        .strip()
    )
    podman(
        "build",
        "--force-rm",
        "--tag=system:latest",
        f"--build-arg=VERSION_ID={uuid}",
        f"--volume={cache}:{cache}",
        f"--file={systemfile}",
    )


def commit(branch: str = "system", rootfs: str | None = None):
    if rootfs is None:
        rootfs = os.path.join(SYSTEM_PATH, "rootfs")

    ostree(
        "commit",
        f"--branch={OS_NAME}/{branch}",
        f"--subject={datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}",
        f"--tree=dir={rootfs}",
    )


def deploy(branch: str = "system", sysroot: str = "/", kernelCommandline: str = ""):
    kargs = ["--karg=root=LABEL=SYS_ROOT", "--karg=rw"]
    for karg in kernelCommandline.split():
        kargs.append(f"--karg={karg.strip()}")

    execute(
        "ostree",
        "admin",
        "deploy",
        f"--sysroot={sysroot}",
        *kargs,
        f"--os={OS_NAME}",
        "--retain",
        f"{OS_NAME}/{branch}",
    )


def revert():
    ostree("admin", "undeploy", "--sysroot=/", "0")


def prune(branch: str = "system"):
    ostree(
        "prune",
        "--commit-only",
        f"--retain-branch-depth={branch}={RETAIN}",
        f"--only-branch={OS_NAME}/{branch}",
        "--keep-younger-than=1 second",
    )
    execute("ostree", "admin", "cleanup")


def install(
    branch: str = "system",
    sysroot: str = "/mnt",
    dev_sys: str | None = None,
    dev_boot: str | None = None,
    kernelCommandline: str = "",
    formatPartitions: bool = False,
    password: str | None = None,
    extraPackages: list[str] | None = None,
):
    if os.path.exists("/ostree"):
        print("Cannot install on existing system")
        sys.exit(1)

    if password is None:
        password = os.environ.get("ROOT_PASSWORD", None)
        if password is None and sys.stdout.isatty():
            # TODO - confirm password
            password = getpass("New root password: ")

        if password is None:
            print("A new root password must be provided")
            sys.exit(1)

    if dev_sys is None:
        print("System partition must be specified")
        sys.exit(1)

    if dev_boot is None:
        print("Boot partition must be specified")
        sys.exit(1)

    setattr(ostree, "repo", f"/mnt{getattr(ostree, 'repo')}")
    if os.path.ismount(sysroot):
        execute("umount", "--recursive", sysroot)

    if formatPartitions:
        execute("mkfs.vfat", "-n", "SYS_BOOT", "-F", "32", dev_boot)
        execute("mkfs.ext4", "-L", "SYS_ROOT", "-F", dev_sys)

    execute("mount", "--mkdir", dev_sys, sysroot)
    execute("mount", "--mkdir", dev_boot, os.path.join(sysroot, "boot/efi"))
    systemDir = os.path.join(sysroot, ".system")
    os.mkdir(systemDir)
    execute("ostree", "admin", "init-fs", f"--sysroot={sysroot}", "--modern", sysroot)
    execute("ostree", "admin", "stateroot-init", f"--sysroot={sysroot}", OS_NAME)
    ostree("init", "--mode=bare")
    ostree("config", "set", "sysroot.bootprefix", "1")
    systemfile = "/tmp/Systemfile"
    if os.path.exists(systemfile):
        os.unlink(systemfile)

    _ = shutil.copy2("/etc/system/Systemfile", systemfile)
    found_build_kernel = False
    with open(systemfile, "r") as f:
        lines = f.readlines()

    with open(systemfile, "w") as f:
        statement: list[str] = []
        for line in lines:
            statement.append(line)
            if line.endswith("\\"):
                continue

            if statement[0].startswith("RUN /usr/lib/system/build_kernel"):
                found_build_kernel = True
                _ = f.write(
                    " \\\n".join(
                        [
                            "RUN /usr/lib/system/install_packages",
                            *[f"  {x}" for x in extraPackages or []],
                        ]
                    )
                    + "\n"
                )

            _ = f.write("".join(statement))
            statement = []

    if not found_build_kernel:
        raise Exception("Unable to find build_kernel call")

    build(systemfile)
    os.unlink(systemfile)
    export(workingDir=systemDir)
    rootfs = os.path.join(systemDir, "rootfs")
    prepare(rootfs)
    buildImage = build_image()
    tmp = os.path.join(sysroot, ".tmp")
    os.mkdir(tmp)
    execute("mount", "-o", "bind", tmp, "/var/tmp")
    exitFunc1 = atexit.register(execute, "umount", "/var/tmp")
    os.mkdir(os.path.join(rootfs, "var/tmp"))
    execute(
        "systemd-nspawn",
        f"--directory={rootfs}",
        "--bind=/run/podman/podman.sock:/run/podman/podman.sock",
        f"--bind={os.path.join(rootfs, 'usr/etc')}:/etc",
        "/bin/bash",
        "-c",
        f"podman --remote save --multi-image-archive system:latest {buildImage} | podman load",
    )
    _ = shutil.rmtree(os.path.join(rootfs, "var/tmp"))
    atexit.unregister(exitFunc1)
    execute("umount", "/var/tmp")
    os.rmdir(tmp)

    commit(branch, rootfs)
    shutil.rmtree(systemDir)
    deploy(branch, sysroot, kernelCommandline)
    execute(
        "grub-install",
        "--target=x86_64-efi",
        f"--efi-directory={sysroot}/boot/efi",
        f"--boot-directory={sysroot}/boot/efi/EFI",
        f"--bootloader-id={OS_NAME}",
        "--removable",
        dev_boot,
    )
    sysPath = [
        x.path
        for x in os.scandir(os.path.join(sysroot, f"ostree/deploy/{OS_NAME}/deploy"))
        if x.is_dir()
    ][0]
    for path in iglob(f"{sysPath}/boot/*"):
        if os.path.islink(path) or os.path.isfile(path):
            os.unlink(path)

        else:
            shutil.rmtree(path)

    os.makedirs(
        os.path.join(sysroot, f"ostree/deploy/{OS_NAME}/var/home"), exist_ok=True
    )
    execute(
        "bash", "-c", f"genfstab -U {sysroot} >> {os.path.join(sysPath, 'etc/fstab')}"
    )
    execute(
        "mount",
        "--mkdir",
        "--rbind",
        os.path.join(sysroot, "boot"),
        os.path.join(sysPath, "boot"),
    )
    execute(
        "mount",
        "--mkdir",
        "--rbind",
        os.path.join(sysroot, "ostree"),
        os.path.join(sysPath, "sysroot/ostree"),
    )
    for i in ["dev", "proc", "sys"]:
        execute("mount", "-o", "bind", f"/{i}", os.path.join(sysPath, i))

    execute(
        "chroot",
        sysPath,
        "/bin/bash",
        "-c",
        "grub-mkconfig -o /boot/efi/EFI/grub/grub.cfg",
    )
    execute(
        "chroot",
        sysPath,
        "/bin/bash",
        "-c",
        shlex.join(["echo", f"root:{password}"]) + " | chpasswd",
    )
    execute("umount", "--recursive", sysroot)


def upgrade(branch: str = "system"):
    if not os.path.exists("/ostree"):
        print("OSTree repo missing")
        sys.exit(1)

    if not os.path.exists(SYSTEM_PATH):
        os.makedirs(SYSTEM_PATH, exist_ok=True)

    build()
    rootfs = os.path.join(SYSTEM_PATH, "rootfs")
    if os.path.exists(rootfs):
        shutil.rmtree(rootfs)

    export(rootfs=rootfs, workingDir=SYSTEM_PATH)
    if os.path.exists("/etc/system/commandline"):
        with open("/etc/system/commandline", "r") as f:
            kernelCommandline = f.read()

    else:
        kernelCommandline = ""

    prepare(rootfs, kernelCommandline)
    commit(branch, rootfs)
    _ = shutil.rmtree(rootfs)
    prune(branch)
    deploy(branch, "/", kernelCommandline)
    execute("grub-mkconfig -o /boot/efi/EFI/grub/grub.cfg")


def iso():
    cwd = os.getcwd()
    os.chdir(SYSTEM_PATH)
    if os.path.exists("archiso"):
        shutil.rmtree("archiso")

    if os.path.exists("work"):
        shutil.rmtree("work")

    uuid = datetime.now().strftime("%Y-%m-%d-%H-%M-%S-00")
    with open("/etc/system/Systemfile", "r") as f:
        buildImage = [
            x.split(" ")[1].strip() for x in f.readlines() if x.startswith("FROM")
        ][0]

    os.chdir("/etc/system")
    podman(
        "build",
        f"--build-arg=UUID={uuid}",
        f"--build-arg=BASE_IMAGE={buildImage}",
        "--force-rm",
        f"--tag=system:iso-{uuid}",
        "--file=/etc/system/Isofile",
    )
    os.chdir(SYSTEM_PATH)
    exitFunc1 = atexit.register(podman, "rmi", f"system:iso-{uuid}")
    rootfs = os.path.join(SYSTEM_PATH, "rootfs")
    if os.path.exists(rootfs):
        shutil.rmtree(rootfs)

    export(
        f"iso-{uuid}",
        f"podman --remote save {buildImage} | podman load",
        rootfs=rootfs,
        workingDir=SYSTEM_PATH,
    )
    atexit.unregister(exitFunc1)
    podman("rmi", f"system:iso-{uuid}")

    _ = shutil.copytree("rootfs/etc/system/archiso", "archiso")
    for path in [
        "loader/entries/01-archiso-x86_64-linux.conf",
        "grub/grub.cfg",
        "syslinux/syslinux-linux.cfg",
    ]:
        with open(os.path.join("archiso", path), "r+") as f:
            content = f.read()
            _ = f.seek(0)
            _ = f.truncate()
            _ = f.write(content.replace("%UUID%", uuid))

    execute("mksquashfs", "rootfs", "archiso/atomic/x86_64/airootfs.sfs")
    _ = shutil.copy2("rootfs/etc/system/efiboot.img", "efiboot.img")
    shutil.rmtree("rootfs")

    parts = buildImage.split(":")
    variant = parts[-1] if len(parts) == 2 else "latest"
    name = f"{OS_NAME}-{variant}-{uuid}.iso"
    # fmt: off
    execute(
        "xorriso",
        "-volume_date", "uuid", uuid.replace("-", ""),
        "-as", "mkisofs",
        "-iso-level", "3",
        "-partition_offset", "16",
        "--mbr-force-bootable",
        "-append_partition", "2", "0xEF", "efiboot.img",
        "-appended_part_as_gpt",
        "-c", "/boot.catalog",
        "-b", "boot/grub/eltorito.img",
        "-no-emul-boot",
        "-boot-load-size", "4",
        "-boot-info-table",
        "--grub2-boot-info",
        "-eltorito-alt-boot",
        "-e", "--interval:appended_partition_2:all::",
        "-no-emul-boot",
        "-o", name,
        "archiso",
    )
    # fmt: on
    os.unlink("efiboot.img")
    shutil.rmtree("archiso")
    os.chdir(cwd)
    return name


def in_system(
    *args: str,
    target: str = "system:latest",
    entrypoint: str = "/usr/bin/os",
    check: bool = False,
) -> int:
    if os.path.exists("/ostree") and os.path.isdir("/ostree"):
        _ostree = "/ostree"
        if not os.path.exists(SYSTEM_PATH):
            os.makedirs(SYSTEM_PATH, exist_ok=True)

        if not os.path.exists(f"{SYSTEM_PATH}/ostree"):
            os.symlink("/ostree", f"{SYSTEM_PATH}/ostree")

    else:
        _ostree = f"{SYSTEM_PATH}/ostree"
        os.makedirs(_ostree, exist_ok=True)
        repo = os.path.join(_ostree, "repo")
        setattr(ostree, "repo", repo)
        if not os.path.exists(repo):
            ostree("init")

    cache = "/var/cache/pacman"
    if not os.path.exists(cache):
        os.makedirs(cache, exist_ok=True)

    cmd = podman_cmd(
        "run",
        "--rm",
        "--privileged",
        "--security-opt=label=disable",
        "--volume=/run/podman/podman.sock:/run/podman/podman.sock",
        f"--volume={SYSTEM_PATH}:{SYSTEM_PATH}",
        f"--volume={_ostree}:/ostree",
        f"--volume={cache}:{cache}",
        f"--entrypoint={entrypoint}",
        target,
        *args,
    )
    ret = _execute(shlex.join(cmd))
    if ret and check:
        raise subprocess.CalledProcessError(ret, cmd, None, None)

    return ret


def checkupdates(baseImage: str | None = None) -> bool:
    if baseImage is None:
        baseImage = build_image()

    digests = [
        x
        for x in subprocess.check_output(
            podman_cmd("inspect", "--format={{ .Digest }}", baseImage)
        )
        .decode("utf-8")
        .strip()
        .split("\n")
        if x
    ]
    image_update = False
    if digests:
        with open("/etc/os-release", "r") as f:
            local_info = {
                x[0]: x[1]
                for x in [
                    x.strip().split("=", 1)
                    for x in f.readlines()
                    if x.startswith("VERSION_ID=") or x.startswith("VERSION=")
                ]
            }

        local_id = local_info.get("VERSION_ID", "0")
        remote_info = cast(
            dict[str, object],
            json.loads(
                subprocess.check_output(
                    [
                        "skopeo",
                        "inspect",
                        f"docker://{baseImage}",
                    ]
                )
            ),
        )
        remote_labels = cast(dict[str, dict[str, str]], remote_info).get("Labels", {})
        remote_id = remote_labels.get("os-release.VERSION_ID", "0")
        if local_id != remote_id:
            remote_version = remote_labels.get("os-release.VERSION", "0")
            local_version = local_info.get("VERSION", "0")
            print(
                f"{baseImage} {local_version}.{local_id} -> {remote_version}.{remote_id}"
            )
            image_update = True

    return in_system(entrypoint="/usr/bin/checkupdates") > 0 or image_update


def do_build(_: argparse.Namespace):
    build()


def do_iso(_: argparse.Namespace):
    name = iso()
    print(f"ISO Created: {name}")


def do_install(args: argparse.Namespace):
    packages = cast(list[str], args.package)
    if not packages:
        packages += ["man-pages", "man-db", "git"]

    if cast(bool, args.nvidia):
        packages += NVIDIA_PACKAGES

    install(
        cast(str, args.branch),
        cast(str, args.sysroot),
        cast(str | None, args.dev_sys),
        cast(str | None, args.dev_boot),
        cast(str, args.kernelCommandline),
        cast(bool, args.formatPartitions),
        cast(str, args.password),
        packages,
    )


def do_upgrade(args: argparse.Namespace):
    if not cast(bool, args.noPull):
        baseImage = build_image()
        try:
            if checkupdates(baseImage):
                podman("pull", baseImage)

        except subprocess.CalledProcessError:
            pass

    upgrade(cast(str, args.branch))


def do_revert(_: argparse.Namespace):
    revert()


def do_export(args: argparse.Namespace):
    export(
        cast(str, args.tag),
        cast(str, args.setup),
        cast(str, args.rootfs),
        cast(str, args.workingDir),
    )


def do_prune(args: argparse.Namespace):
    prune(cast(str, args.branch))


def do_deploy(args: argparse.Namespace):
    deploy(cast(str, args.branch))


def do_prepare(args: argparse.Namespace):
    prepare(cast(str, args.rootfs), cast(str, args.kernelCommandline))


def do_commit(args: argparse.Namespace):
    commit(cast(str, args.branch), cast(str, args.rootfs))


def do_checkupdates(args: argparse.Namespace):
    updates = False
    try:
        updates = checkupdates(cast(str, args.baseImage))

    except BaseException:
        traceback.print_exc()
        sys.exit(1)

    if updates:
        sys.exit(2)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="os", description="Manage your operating system", add_help=True
    )
    subparsers = parser.add_subparsers(help="Action to run")

    subparser = subparsers.add_parser("build", help="Build your system image")
    subparser.set_defaults(func=do_build)

    subparser = subparsers.add_parser(
        "iso", help="Build a bootable ISO image to install your system"
    )
    subparser.set_defaults(func=do_iso)

    subparser = subparsers.add_parser(
        "install", help="When in install media, install your system"
    )
    _ = subparser.add_argument(
        "--branch", default="system", help="System branch to prune"
    )
    _ = subparser.add_argument(
        "--sysroot", default="/mnt", help="Location to use for mounting target install"
    )
    _ = subparser.add_argument(
        "--kernel-commandline",
        default="",
        help="Kernel command line arguments",
        dest="kernelCommandline",
    )
    _ = subparser.add_argument(
        "--system-partition",
        default=None,
        help="Partition to install the system to",
        dest="dev_sys",
    )
    _ = subparser.add_argument(
        "--boot-partition",
        default=None,
        help="Partition to install the bootloader to",
        dest="dev_boot",
    )
    _ = subparser.add_argument(
        "--format-partitions",
        action="store_true",
        dest="formatPartitions",
        help="Format the partitions before installing",
    )
    _ = subparser.add_argument("--password", default=None, help="New root password")
    _ = subparser.add_argument(
        "--package", action="append", help="Extra package to install", default=[]
    )
    _ = subparser.add_argument(
        "--nvidia", action="store_true", help="Install nvidia packages"
    )
    subparser.set_defaults(func=do_install)

    subparser = subparsers.add_parser("upgrade", help="Perform a system upgrade")
    _ = subparser.add_argument(
        "--branch", default="system", help="System branch to prune"
    )
    _ = subparser.add_argument(
        "--no-pull",
        help="Do not pull base image updates",
        action="store_true",
        dest="noPull",
    )
    subparser.set_defaults(func=do_upgrade)

    subparser = subparsers.add_parser("revert", help="Revert the last system upgrade")
    subparser.set_defaults(func=do_revert)

    subparser = subparsers.add_parser(
        "export", help="Export your current system image to a folder"
    )
    _ = subparser.add_argument(
        "--tag", default="latest", help="System image version to export"
    )
    _ = subparser.add_argument(
        "--rootfs", default=SYSTEM_PATH, help="Directory to export to"
    )
    _ = subparser.add_argument(
        "--workingDir",
        default=SYSTEM_PATH,
        help="Working directory to use while exporting",
    )
    _ = subparser.add_argument(
        "--setup",
        default="",
        help="Script to run against the system image before exproting it",
    )
    subparser.set_defaults(func=do_export)

    subparser = subparsers.add_parser("prune", help="Prune the system ostree")
    _ = subparser.add_argument(
        "--branch", default="system", help="System branch to prune"
    )
    subparser.set_defaults(func=do_prune)

    subparser = subparsers.add_parser("deploy", help="deploy the system ostree")
    _ = subparser.add_argument(
        "--branch", default="system", help="System branch to deploy"
    )
    _ = subparser.add_argument(
        "--sysroot", default="/", help="Root of the filesystem that contains ostree"
    )
    subparser.set_defaults(func=do_deploy)

    subparser = subparsers.add_parser(
        "prepare", help="Prepare an exported rootfs from a system image"
    )
    _ = subparser.add_argument(
        "--kernel-commandline",
        default="",
        help="Kernel command line arguments",
        dest="kernelCommandline",
    )
    _ = subparser.add_argument(
        "--rootfs", default="/", help="Exported rootfs to prepare"
    )
    subparser.set_defaults(func=do_deploy)

    subparser = subparsers.add_parser("commit", help="Commit to the system ostree")
    _ = subparser.add_argument(
        "--branch", default="system", help="System branch to commit"
    )
    _ = subparser.add_argument("--rootfs", default="/", help="Rootfs to commit")
    subparser.set_defaults(func=do_commit)

    subparser = subparsers.add_parser(
        "checkupdates", help="Checks for updates to the system"
    )
    _ = subparser.add_argument(
        "--base-image", default=None, help="Base image to check", dest="baseImage"
    )
    subparser.set_defaults(func=do_checkupdates)

    args = parser.parse_args()
    if not hasattr(args, "func"):
        parser.print_help()
        sys.exit(1)

    if not is_root():
        print("Must be run as root")
        sys.exit(1)

    cast(Callable[[argparse.Namespace], None], args.func)(args)
