#!/usr/bin/python
import argparse
import atexit
from getpass import getpass
import os
from re import sub
import shlex
import shutil
import subprocess
import sys
import tarfile

from time import time
from glob import iglob
from datetime import datetime
from typing import Callable, cast


SYSTEM_PATH = "/var/lib/system"
RETAIN = 5
COMMAND_LINE = ""
NVIDIA_PACKAGES = ["nvidia-open-dkms", "nvidia-container-toolkit", "nvidia-utils"]


def _execute(cmd: str):
    status = os.system(cmd)
    return os.waitstatus_to_exitcode(status)


def execute(cmd: str | list[str], *args: str):
    if not isinstance(cmd, str):
        cmd = shlex.join(cmd)

    if args:
        cmd = f"{cmd} {shlex.join(args)}"

    ret = _execute(cmd)
    if ret:
        raise subprocess.CalledProcessError(ret, cmd, None, None)


def podman_cmd(*args: str):
    if _execute("systemd-detect-virt --quiet --container") == 0:
        return ["podman", "--remote", *args]

    return ["podman", *args]


def podman(*args: str):
    execute(*podman_cmd(*args))


def ostree(*args: str):
    execute("ostree", f"--repo={getattr(ostree, 'repo')}", *args)


setattr(ostree, "repo", "/ostree/repo")


def export(
    tag: str = "latest",
    setup: str = "",
    rootfs: str | None = None,
    workingDir: str | None = None,
):
    if workingDir is None:
        workingDir = SYSTEM_PATH

    if rootfs is None:
        rootfs = os.path.join(workingDir, "rootfs")

    if os.path.exists(rootfs):
        shutil.rmtree(rootfs)

    cwd = os.getcwd()
    os.chdir(workingDir)
    timestamp = int(time())
    name = f"export-{tag}-{timestamp}"
    exitFunc1 = atexit.register(podman, "rm", name)
    podman(
        "run",
        f"--name={name}",
        "--privileged",
        "--security-opt=label=disable",
        "--volume=/run/podman/podman.sock:/run/podman/podman.sock",
        f"system:{tag}",
        "-c",
        setup,
    )
    os.makedirs(rootfs, exist_ok=True)
    cmd = podman_cmd("export", name)
    process = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    assert process.stdout is not None
    with tarfile.open(fileobj=process.stdout, mode="r|*") as t:
        t.extractall(rootfs, numeric_owner=True, filter="fully_trusted")

    process.stdout.close()
    _ = process.wait()
    if process.returncode != 0:
        raise subprocess.CalledProcessError(process.returncode, cmd, None, None)

    atexit.unregister(exitFunc1)
    podman("rm", name)
    os.chdir(cwd)


TMPFILE_CONF = """
d /var/home 0755 root root -
d /var/lib 0755 root root -
d /var/log/journal 0755 root root -
d /var/media 0755 root root -
d /var/mnt 0755 root root -
d /var/opt 0755 root root -
d /var/roothome 0755 root root -
d /var/srv 0755 root root -
d /var/userlocal 0755 root root -
d /var/userlocal/bin 0755 root root -
d /var/userlocal/etc 0755 root root -
d /var/userlocal/games 0755 root root -
d /var/userlocal/include 0755 root root -
d /var/userlocal/lib 0755 root root -
d /var/userlocal/man 0755 root root -
d /var/userlocal/sbin 0755 root root -
d /var/userlocal/share 0755 root root -
d /var/userlocal/src 0755 root root -
"""


def prepare(rootfs: str, kernelCommandline: str = ""):
    cwd = os.getcwd()
    os.chdir(rootfs)
    with open("etc/system/commandline", "w") as f:
        _ = f.write(kernelCommandline)

    _ = shutil.move("etc", "usr")

    def var_link(name: str):
        shutil.rmtree(name)
        os.symlink(f"var/{name}", name)

    var_link("home")
    var_link("mnt")
    var_link("opt")
    shutil.rmtree("root")
    os.symlink("var/roothome", "root")
    var_link("srv")
    os.mkdir("sysroot")
    os.symlink("sysroot/ostree", "ostree")
    shutil.rmtree("usr/local")
    os.symlink("../var/userlocal", "usr/local")
    with open("usr/lib/tmpfiles.d/ostree-0-integration.conf", "w") as f:
        _ = f.write(TMPFILE_CONF)

    _ = shutil.move("var/lib/pacman", "usr/lib")
    execute(
        "sed",
        "-i",
        "-e",
        r"s|^#\(DBPath\s*=\s*\).*|\1/usr/lib/pacman|g",
        "-e",
        r"s|^#\(IgnoreGroup\s*=\s*\).*|\1modified|g",
        "usr/etc/pacman.conf",
    )
    os.mkdir("usr/lib/pacmanlocal")
    for path in iglob("var/*"):
        if os.path.islink(path) or os.path.isfile(path):
            os.unlink(path)

        else:
            shutil.rmtree(path)

    os.unlink("boot/vmlinuz-linux-zen")
    modulePath = [*iglob("usr/lib/modules/*")][0]
    os.rename("boot/initramfs-linux-zen.img", f"{modulePath}/initramfs.img")
    os.chdir(cwd)


def build(systemfile: str = "/etc/system/Systemfile"):
    podman(
        "build",
        "--force-rm",
        "--tag=system:latest",
        "--volume=/var/cache/pacman:/var/cache/pacman",
        f"--file={systemfile}",
    )


def commit(branch: str = "system", rootfs: str | None = None):
    if rootfs is None:
        rootfs = os.path.join(SYSTEM_PATH, "rootfs")

    ostree(
        "commit",
        f"--branch=atomic-arch/{branch}",
        f"--subject={datetime.now().strftime('%Y-%m-%d-%H-%M-%S')}",
        f"--tree=dir={rootfs}",
    )


def deploy(branch: str = "system", sysroot: str = "/", kernelCommandline: str = ""):
    execute(
        "ostree",
        "admin",
        "deploy",
        f"--sysroot={sysroot}",
        f"--karg=root=LABEL=SYS_ROOT {kernelCommandline} rw",
        "--os=atomic-arch",
        "--retain",
        f"atomic-arch/{branch}",
    )


def revert():
    ostree("admin", "undeploy", "--sysroot=/", "0")


def prune(branch: str = "system"):
    ostree(
        "prune",
        "--commit-only",
        f"--retain-branch-depth={branch}={RETAIN}",
        f"--only-branch=atomic-arch/{branch}",
        "--keep-younger-than=1 second",
    )


def install(
    branch: str = "system",
    sysroot: str = "/mnt",
    dev_sys: str | None = None,
    dev_boot: str | None = None,
    kernelCommandline: str = "",
    formatPartitions: bool = False,
    password: str | None = None,
    extraPackages: list[str] | None = None,
):
    if os.path.exists("/ostree"):
        print("Cannot install on existing system")
        sys.exit(1)

    if password is None:
        password = os.environ.get("ROOT_PASSWORD", None)
        if password is None and sys.stdout.isatty():
            # TODO - confirm password
            password = getpass("New root password: ")

        if password is None:
            print("A new root password must be provided")
            sys.exit(1)

    if dev_sys is None:
        print("System partition must be specified")
        sys.exit(1)

    if dev_boot is None:
        print("Boot partition must be specified")
        sys.exit(1)

    setattr(ostree, "repo", f"/mnt{getattr(ostree, 'repo')}")
    if os.path.ismount(sysroot):
        execute("umount", "--recursive", sysroot)

    if formatPartitions:
        execute("mkfs.vfat", "-n", "SYS_BOOT", "-F", "32", dev_boot)
        execute("mkfs.ext4", "-L", "SYS_ROOT", "-F", dev_sys)

    execute("mount", "--mkdir", dev_sys, sysroot)
    execute("mount", "--mkdir", dev_boot, os.path.join(sysroot, "boot/efi"))
    systemDir = os.path.join(sysroot, ".system")
    os.mkdir(systemDir)
    execute("ostree", "admin", "init-fs", f"--sysroot={sysroot}", "--modern", sysroot)
    execute("ostree", "admin", "stateroot-init", f"--sysroot={sysroot}", "atomic-arch")
    ostree("init", "--mode=bare")
    ostree("config", "set", "sysroot.bootprefix", "1")
    systemfile = "/tmp/Systemfile"
    if os.path.exists(systemfile):
        os.unlink(systemfile)

    _ = shutil.copy2("/etc/system/Systemfile", systemfile)
    found_build_kernel = False
    with open(systemfile, "r+") as f:
        lines = f.readlines()
        _ = f.seek(0)
        statement: list[str] = []
        for line in lines:
            statement += line
            if line.endswith("\\"):
                continue

            if statement[0].startswith("RUN /usr/lib/system/build_kernel"):
                found_build_kernel = True
                _ = f.write(
                    "\n".join(
                        [
                            "RUN /usr/lib/system/install_packages \\",
                            *[f"  {x} \\" for x in extraPackages or []],
                        ]
                    )
                )

            _ = f.write("\n".join(statement))

    if not found_build_kernel:
        raise Exception("Unable to find build_kernel call")

    build(systemfile)
    os.unlink(systemfile)
    export(workingDir=systemDir)
    rootfs = os.path.join(systemDir, "rootfs")
    prepare(rootfs)

    with open("/etc/system/Systemfile", "r") as f:
        buildImage = [
            x.split(" ")[1].strip() for x in f.readlines() if x.startswith("FROM")
        ][0]

    tmp = os.path.join(sysroot, ".tmp")
    os.mkdir(tmp)
    execute("mount", "-o", "bind", tmp, "/var/tmp")
    exitFunc1 = atexit.register(execute, "umount", "/var/tmp")
    os.mkdir(os.path.join(rootfs, "var/tmp"))
    execute(
        "systemd-nspawn",
        f"--directory={rootfs}",
        "--bind=/run/podman/podman.sock:/run/podman/podman.sock",
        f"--bind={os.path.join(rootfs, 'usr/etc')}:/etc",
        "/bin/bash",
        "-c",
        f"podman --remote save --multi-image-archive system:latest {buildImage} | podman load",
    )
    _ = shutil.rmtree(os.path.join(rootfs, "var/tmp"))
    atexit.unregister(exitFunc1)
    execute("umount", "/var/tmp")
    os.rmdir(tmp)

    commit(branch, rootfs)
    shutil.rmtree(systemDir)
    deploy(branch, sysroot, kernelCommandline)
    execute(
        "grub-install",
        "--target=x86_64-efi",
        f"--efi-directory={sysroot}/boot/efi",
        f"--boot-directory={sysroot}/boot/efi/EFI",
        "--bootloader-id=atomic-arch",
        "--removable",
        dev_boot,
    )
    sysPath = [
        x.path
        for x in os.scandir(os.path.join(sysroot, "ostree/deploy/atomic-arch/deploy"))
        if x.is_dir()
    ][0]
    for path in iglob(f"{sysPath}/boot/*"):
        if os.path.islink(path) or os.path.isfile(path):
            os.unlink(path)

        else:
            shutil.rmtree(path)

    os.makedirs(
        os.path.join(sysroot, "ostree/deploy/atomic-arch/var/home"), exist_ok=True
    )
    execute(
        "bash", "-c", f"genfstab -U {sysroot} >> {os.path.join(sysPath, 'etc/fstab')}"
    )
    execute(
        "mount",
        "--mkdir",
        "--rbind",
        os.path.join(sysroot, "boot"),
        os.path.join(sysPath, "boot"),
    )
    execute(
        "mount",
        "--mkdir",
        "--rbind",
        os.path.join(sysroot, "ostree"),
        os.path.join(sysPath, "sysroot/ostree"),
    )
    for i in ["dev", "proc", "sys"]:
        execute("mount", "-o", "bind", f"/{i}", os.path.join(sysPath, i))

    execute(
        "chroot",
        sysPath,
        "/bin/bash",
        "-c",
        "grub-mkconfig -o /boot/efi/EFI/grub/grub.cfg",
    )
    execute(
        "chroot",
        sysPath,
        "/bin/bash",
        "-c",
        shlex.join(["echo", f"root:{password}"]) + " | chpasswd",
    )
    execute("umount", "--recursive", sysroot)


def upgrade(branch: str = "system"):
    if not os.path.exists("/ostree"):
        print("OSTree repo missing")
        sys.exit(1)

    if not os.path.exists(SYSTEM_PATH):
        os.makedirs(SYSTEM_PATH, exist_ok=True)

    build()
    rootfs = os.path.join(SYSTEM_PATH, "rootfs")
    if os.path.exists(rootfs):
        shutil.rmtree(rootfs)

    export(rootfs=rootfs, workingDir=SYSTEM_PATH)
    if os.path.exists("/etc/system/commandline"):
        with open("/etc/system/commandline", "r") as f:
            kernelCommandline = f.read()

    else:
        kernelCommandline = ""

    prepare(rootfs, kernelCommandline)
    commit(branch, rootfs)
    prune(branch)
    deploy(branch, "/", kernelCommandline)
    execute("grub-mkconfig -o /boot/efi/EFI/grub/grub.cfg")


def iso():
    cwd = os.getcwd()
    os.chdir(SYSTEM_PATH)
    if os.path.exists("archiso"):
        shutil.rmtree("archiso")

    if os.path.exists("work"):
        shutil.rmtree("work")

    uuid = datetime.now().strftime("%Y-%m-%d-%H-%M-%S-00")
    with open("/etc/system/Systemfile", "r") as f:
        buildImage = [
            x.split(" ")[1].strip() for x in f.readlines() if x.startswith("FROM")
        ][0]

    os.chdir("/etc/system")
    podman(
        "build",
        f"--build-arg=UUID={uuid}",
        f"--build-arg=BASE_IMAGE={buildImage}",
        "--force-rm",
        f"--tag=system:iso-{uuid}",
        "--file=/etc/system/Isofile",
    )
    os.chdir(SYSTEM_PATH)
    exitFunc1 = atexit.register(podman, "rmi", f"system:iso-{uuid}")
    rootfs = os.path.join(SYSTEM_PATH, "rootfs")
    if os.path.exists(rootfs):
        shutil.rmtree(rootfs)

    export(
        f"iso-{uuid}",
        f"podman --remote save {buildImage} | podman load",
        rootfs=rootfs,
        workingDir=SYSTEM_PATH,
    )
    atexit.unregister(exitFunc1)
    podman("rmi", f"system:iso-{uuid}")

    _ = shutil.copytree("rootfs/etc/system/archiso", "archiso")
    for path in [
        "loader/entries/01-archiso-x86_64-linux.conf",
        "grub/grub.cfg",
        "syslinux/syslinux-linux.cfg",
    ]:
        with open(os.path.join("archiso", path), "r+") as f:
            content = f.read()
            _ = f.seek(0)
            _ = f.truncate()
            _ = f.write(content.replace("%UUID%", uuid))

    execute("mksquashfs", "rootfs", "archiso/atomic/x86_64/airootfs.sfs")
    _ = shutil.copy2("rootfs/etc/system/efiboot.img", "efiboot.img")
    shutil.rmtree("rootfs")

    name = f"atomic-arch-{uuid}.iso"
    # fmt: off
    execute(
        "xorriso",
        "-volume_date", "uuid", uuid.replace("-", ""),
        "-as", "mkisofs",
        "-iso-level", "3",
        "-partition_offset", "16",
        "--mbr-force-bootable",
        "-append_partition", "2", "0xEF", "efiboot.img",
        "-appended_part_as_gpt",
        "-c", "/boot.catalog",
        "-b", "boot/grub/eltorito.img",
        "-no-emul-boot",
        "-boot-load-size", "4",
        "-boot-info-table",
        "--grub2-boot-info",
        "-eltorito-alt-boot",
        "-e", "--interval:appended_partition_2:all::",
        "-no-emul-boot",
        "-o", name,
        "archiso",
    )
    # fmt: on
    os.unlink("efiboot.img")
    shutil.rmtree("archiso")
    os.chdir(cwd)
    return name


def do_build(_: argparse.Namespace):
    build()


def do_iso(_: argparse.Namespace):
    name = iso()
    print(f"ISO Created: {name}")


def do_install(args: argparse.Namespace):
    packages = cast(list[str], args.package)
    if not packages:
        packages += ["man-pages", "man-db", "git"]

    if cast(bool, args.nvidia):
        packages += NVIDIA_PACKAGES

    install(
        cast(str, args.branch),
        cast(str, args.sysroot),
        cast(str | None, args.dev_sys),
        cast(str | None, args.dev_boot),
        cast(str, args.kernelCommandline),
        cast(bool, args.formatPartitions),
        cast(str, args.password),
        packages,
    )


def do_upgrade(args: argparse.Namespace):
    upgrade(cast(str, args.branch))


def do_revert(_: argparse.Namespace):
    revert()


def do_export(args: argparse.Namespace):
    export(
        cast(str, args.tag),
        cast(str, args.setup),
        cast(str, args.rootfs),
        cast(str, args.workingDir),
    )


def do_prune(args: argparse.Namespace):
    prune(cast(str, args.branch))


def do_deploy(args: argparse.Namespace):
    deploy(cast(str, args.branch))


def do_prepare(args: argparse.Namespace):
    prepare(cast(str, args.rootfs), cast(str, args.kernelCommandline))


def do_commit(args: argparse.Namespace):
    commit(cast(str, args.branch), cast(str, args.rootfs))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="os", description="Manage your operating system", add_help=True
    )
    subparsers = parser.add_subparsers(help="Action to run")

    subparser = subparsers.add_parser("build", help="Build your system image")
    subparser.set_defaults(func=do_build)

    subparser = subparsers.add_parser(
        "iso", help="Build a bootable ISO image to install your system"
    )
    subparser.set_defaults(func=do_iso)

    subparser = subparsers.add_parser(
        "install", help="When in install media, install your system"
    )
    _ = subparser.add_argument(
        "--branch", default="system", help="System branch to prune"
    )
    _ = subparser.add_argument(
        "--sysroot", default="/mnt", help="Location to use for mounting target install"
    )
    _ = subparser.add_argument(
        "--kernel-commandline",
        default="",
        help="Kernel command line arguments",
        dest="kernelCommandline",
    )
    _ = subparser.add_argument(
        "--system-partition",
        default=None,
        help="Partition to install the system to",
        dest="dev_sys",
    )
    _ = subparser.add_argument(
        "--boot-partition",
        default=None,
        help="Partition to install the bootloader to",
        dest="dev_boot",
    )
    _ = subparser.add_argument(
        "--format-partitions",
        action="store_true",
        dest="formatPartitions",
        help="Format the partitions before installing",
    )
    _ = subparser.add_argument("--password", default=None, help="New root password")
    _ = subparser.add_argument(
        "--package", action="append", help="Extra package to install"
    )
    _ = subparser.add_argument(
        "--nvidia", action="store_true", help="Install nvidia packages"
    )
    subparser.set_defaults(func=do_install)

    subparser = subparsers.add_parser("upgrade", help="Perform a system upgrade")
    _ = subparser.add_argument(
        "--branch", default="system", help="System branch to prune"
    )
    subparser.set_defaults(func=do_upgrade)

    subparser = subparsers.add_parser("revert", help="Revert the last system upgrade")
    subparser.set_defaults(func=do_revert)

    subparser = subparsers.add_parser(
        "export", help="Export your current system image to a folder"
    )
    _ = subparser.add_argument(
        "--tag", default="latest", help="System image version to export"
    )
    _ = subparser.add_argument(
        "--rootfs", default=SYSTEM_PATH, help="Directory to export to"
    )
    _ = subparser.add_argument(
        "--workingDir",
        default=SYSTEM_PATH,
        help="Working directory to use while exporting",
    )
    _ = subparser.add_argument(
        "--setup",
        default="",
        help="Script to run against the system image before exproting it",
    )
    subparser.set_defaults(func=do_export)

    subparser = subparsers.add_parser("prune", help="Prune the system ostree")
    _ = subparser.add_argument(
        "--branch", default="system", help="System branch to prune"
    )
    subparser.set_defaults(func=do_prune)

    subparser = subparsers.add_parser("deploy", help="deploy the system ostree")
    _ = subparser.add_argument(
        "--branch", default="system", help="System branch to deploy"
    )
    _ = subparser.add_argument(
        "--sysroot", default="/", help="Root of the filesystem that contains ostree"
    )
    subparser.set_defaults(func=do_deploy)

    subparser = subparsers.add_parser(
        "prepare", help="Prepare an exported rootfs from a system image"
    )
    _ = subparser.add_argument(
        "--kernel-commandline",
        default="",
        help="Kernel command line arguments",
        dest="kernelCommandline",
    )
    _ = subparser.add_argument(
        "--rootfs", default="/", help="Exported rootfs to prepare"
    )
    subparser.set_defaults(func=do_deploy)

    subparser = subparsers.add_parser("commit", help="Commit to the system ostree")
    _ = subparser.add_argument(
        "--branch", default="system", help="System branch to commit"
    )
    _ = subparser.add_argument("--rootfs", default="/", help="Rootfs to commit")
    subparser.set_defaults(func=do_deploy)

    args = parser.parse_args()
    if not hasattr(args, "func"):
        parser.print_help()
        sys.exit(1)

    cast(Callable[[argparse.Namespace], None], args.func)(args)
